## Лекция №2

### Что будет, если в нашу систему ввести тип Bool?

Попробуйте переписать все правила подходящим образом

|                        |                                                |
|------------------------|------------------------------------------------|
| `input`                | `⟦⟦input⟧⟧ = α`                                |
| `input`                | `⟦⟦input⟧⟧ = α`                                |
| `output E`             | `⟦⟦E⟧⟧ = α`                                    |
| `E1 cmp E2`            | `⟦⟦E1⟧⟧ = ⟦⟦E2⟧⟧ = int ∧ ⟦⟦E1 cmp E2⟧⟧ = bool` |
| `if(E) {S}`            | `⟦⟦E⟧⟧ = bool`                                 |
| `if(E) {S1} else {S2}` | `⟦⟦E⟧⟧ = bool`                                 |
| `while(E) {S}`         | `⟦⟦E⟧⟧ = bool`                                 |

- Будет ли анализ более полным?

нет, поскольку не будут проходить проверку if/while, в которые модет передаваться int

- более точным?

Нет, анализ типов soundness

### Что будет, если в нашу систему ввести тип Array?

### Придумайте правила вывода для новых операторов

|                |                                                       |
|----------------|-------------------------------------------------------|
| `{}`           | `⟦⟦{}⟧⟧ = α[]`                                        |
| `{E1,..., En}` | `⟦⟦E1⟧⟧ = ... = ⟦⟦En⟧⟧ ∧ ⟦⟦{E1,..., En}⟧⟧ = ⟦⟦E1⟧⟧[]` |
| `E1[E2]`       | `⟦⟦E1⟧⟧ = α[] ∧ ⟦⟦E2⟧⟧ = int ∧ ⟦⟦E1[E2]⟧⟧ = α`        |
| `E1[E2] = E3`  | `⟦⟦E1⟧⟧ = α[] ∧ ⟦⟦E2⟧⟧ = int ∧ ⟦⟦E3⟧⟧ = α`            |

### Попробуйте протипизировать программу со слайда

```
main() {
    var x,y,z,t;           
    x = {2,4,8,16,32,64};  // ⟦⟦x⟧⟧ == Array<Int>
    y = x[x[3]];           // ⟦⟦y⟧⟧ == Int
    z = {{},x};            // ⟦⟦z⟧⟧ == Array<Array<Int>>
    t = z[1];              // ⟦⟦t⟧⟧ == Array<Int>
    t[2] = y;
}
```

### Подумайте, что происходит в получившейся реализации, если в программе есть рекурсивный тип?

В реализации используется регулярная унификация, которая допускает такие типы, и выводит их в μ-нотации:

`./tip -run -types examples/rectype.tip`:

```
[info] Inferred types:
  ⟦0[5:12]⟧ = int
  ⟦null[3:15]⟧ = ⭡x7
  ⟦main(){...}:1:1⟧ = () -> x5
  ⟦p[2:9]⟧ = ⭡μx6.⭡x6
  ⟦alloc null[3:9]⟧ = ⭡μx6.⭡x6
```

### Дописать реализацию класса TypeAnalysis в TIP (паттерн матчинг — ваш друг!)

https://github.com/deevroman/TIP/commit/d215cd966fc315fe886232bc8acb968fcf3d7572

## Лекция №3

### У решетки есть максимальный и минимальный элементы (⊤, ⊥)
• Являются ли они точной верхней или нижней гранью какого-либо подмножества S?

Да, поскольку решётка это poset для любых двух элементов, которого есть точные верхняя и нижняя грани, а максимальный элемент решётки является точной верхней гранью для множества. Аналогично для минимального.

• Уникальны ли они?

Точные грани должны быть уникальны, иначе снова противоречие определению решётки.


### Можно ли выразить анализ типов с предыдущей лекции как анализ над решетками?
• Если да, то как выглядит наша решетка?

Да, если имеется общий для всех типов над- и под-типы, тогда можно построить flat-решётку, с оставшимися типами.


### Можно ли выразить анализ над решетками как анализ типов?
• Короткий ответ: да, можно (subtyping)
• Длинный ответ: подумайте, все ли выразимо в таком случае

Нужны ⊤, ⊥, которых в системе типов может не быть.

### Допишите метод transfer в трейте IntraprocSignAnalysisFunctions2
### Реализуйте класс PowersetLattice в файле GenericLattices3

https://github.com/deevroman/TIP/commit/253defb28a59e6f5c583443f5026a3516d26802d

## Лекиция №4

### Какова сложность структурного алгоритма? (для liveness analysis)

$O(n k^2)$ где $n$ — количество узлов в графе, $k$ — количество переменных, а также второе $k$ вытекающее в худшем случае из обхода всего графа при обновлении информации о переменной.

### А если в CFG нет циклов?

Уходит $k$ посокольку каждый узел обрабатывается один раз.

### Какова сложность по памяти?

$O(n k)$ — для каждого из $n$ узлов храним состояние о $k$ переменных


### Допишите реализацию live variables analysis
### Реализуйте reaching definitions analysis

https://github.com/deevroman/TIP/commit/9dfb5d1a62542175a168f8178296a3480dbf556f

## Лекция №5

Допустим, мы хотим реализовать оптимизирующий компилятор для языка TIP. Среди прочего, для работы ему требуется
информация о размерах различных переменных.
- • bool (1 bit)
- • byte (8 bit signed)
- • char (16 bit unsigned)
- • int (32 bit signed)
- • bigint (any integer)
- • any (any thing)
- • ‘(T) E‘ — операция приведения типов

### Предложите решетку для реализации анализа размера переменных
### Опишите правила вычисления различных выражений
### Придумайте нетривиальный пример программы на TIP для получившегося анализа и посмотрите, что для него получается

• Нужно описать не только решетку для одного абстрактного значения, но и все другие решетки, требуемые для анализа целой программы

Интервалы для упомянутых типов:

|          |                       |
|----------|-----------------------|
| `bool`   | $[0; 1]$              |
| `byte`   | $[-2^7; 2^7-1]$       |
| `char`   | $[0; 2^{16}-1]$       |
| `int`    | $[-2^{32}; 2^{32}-1]$ |
| `bigint` | $[-\infty; +\infty]$  |
| `any`    | -                     |

Также нам нужна решётка оторажений переменных в интервалы.
Для реализации заменим множество в уже реализованном интервальном анализе на значения степеней двоек и +inf, -inf.

### Допишите реализацию метода widen в
### Реализуйте придуманный вами анализ размера переменных

https://github.com/deevroman/TIP/commit/b897e640e7646cc32a561585a3a326af3c455144

```
./tip -run -types -interval wlrw -size wlrw examples/interval1.tip`
dot -O -Tpng ./out/interval1.tip__interval.dot
```

![](/out/interval1.tip__interval.dot.png)

## Лекция №6
### Напишите вариант программы, для которой анализ открытости-закрытости файлов не показывает корректный результат даже с учётом всех возможных условий в переходах

```
main() {
    var flag
    flag = input
    if (flag) {
        open()
    } else {
        close()
    }
}
```

Также анализ не справится, если условие приходит посредствой вызова какой-то функции

### Предложите, каким образом можно решить описанные в лекции проблемы в этой ситуации

Можно:
- Поддержать межпроцедурный анализ
- Запускать дополнительные анализы
- Кластеризовывать переменные
- Нормализоывать выражения

## Лекция №8

### Напишите вариант программы, для которой контекстно-чувствительный анализ знаков требует коэффициент `k > 1`

Любой вызов рекурсивной функции глубины больше $k$

### Приведите пример решётки, для которой контекстно-чувствительный анализ в функциональном стиле является более ресурсозатратным, чем контекстно-чувствительный анализ по месту вызова с глубиной 2

Решетка для контекстно-чувствительного анализа: $Nodes \rightarrow Contexts \rightarrow lift(States)$

По месту вызова: $Contexts = Calls^k = Calls^2$

В функциональном стиле, если взять powerset переменных: $Contexts = States = 2^{Vars}$

